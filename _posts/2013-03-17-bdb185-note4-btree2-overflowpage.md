---
layout: post
title: bdb1.85源码学习笔记4_btree2_OverflowPage
description : ""
category :
tags: []
---

# bdb1.85源码学习笔记4_btree2_OverflowPage

这里讲的是bt_overflow.c里的代码.在btree中,每一个节点就是一个页面.页面内会存key和data.但是key和data如果数据量很大,一个页面放不下,或者哪怕能放下,一个页面只放2个key也没什么意义了.所以这里就特别对大数据进行了一些处理. 要特别感谢以下这个博客,因为接下来bdb代码的阅读,参考了这个博客的很多内容. <http://blog.csdn.net/missyou03/article/category/713017> 什么数据被认为是大数据?其实,这个答案也还没有找出来,因为还在阅读代码中.这个问题留着,等读到后面了,估计就有答案了. 在bt_overflow.c里,有3个函数,分别是__ovfl_get,__ovfl_put,__ovfl_delete在说操作前,先说说big data在页上是怎么存的. ![](/wp-content/uploads/2013/03/overflow_page.png) 如果一个数据(可能是key,也可能是key+data),那么这个数据就不会被放在bytes中.这些数据会被放在其他的页中.从图中来看,这些数据会被放在overflow page中,这些page除了页头外,其余空间都用来放数据.一个数据可能很大,一个页面放不下,没关系,用页面链表.那么本来放数据的bytes就变成了放这个链表的起始页的页号pgno,以及数据的大小data size. 

  * **__ovfl_put**
让入大数据,也就是将大数据放入到页链表中,并返回这个链表的起始页号. 参数: dbt, 要存入页内的数据; pg,其实这是返回值,返回大数据的起始页 过程: 
  1. plen,计算1个页最多可以存多少的数据,也就是页大小减去页头剩余的空间都用来存数据.
  2. 传入的dbt参数,是个结构体,有两个变量,一个是data,指向数据所在空间的指针,另一个是size,指明数据的大小.这里使用for循环,将数据数据写入到页链表中.变量p表示当前数据写到什么位置,sz表示剩余多少数据要写,last记录上一个写完的页面.存储大数据,整个页面除了页头,其余空间都用来存储数据,因此p每次移动的大小就是plen的大小.
  3. 首先调用__bt_new,申请一个页,返回的页指针给h,同时npg返回页号.初始化这个页的信息,重要的是要把h->flags设为P_OVERFLOW.
  4. 比较sz和plen的大小.nb记录更小的值.起始nb记录的就是接下来要写入页面的数据的大小.考虑两种情况,剩余要写的数据大于一个页面能容纳的量,所以接下来要写的数据大小就是plen;反之,如果剩余数据小于或者等于一个页面能容纳的量,那么接写来要写的数据大小就是剩余的数据大小sz.
  5. 如果last是null,那么当前这个页就是链表的页首,将页首地址赋值给pg,以便作为返回值返回.若last不是null,那么就将上一个页的nextpg赋值为当前页的页号(因为这是一个链表,需要将上一个页和当前页连起来),然后讲用完的last页还给mpool.
  6. 最后判断,如果数据已经写完,那么就将最后一页还给mpool,同时退出循环,返回.这里一开始我会疑惑,sz-nb一定等于0吗?是的,如果这是最后的数据,一定会等于0的.因为nb取的是sz和plen的最小值.
  * **__ovfl_get**
根据大数据链表的起始页号,获得链表中的大数据.返回值是大数据的buffer和buffer的大小. 参数: 
  1. p,这里是通用指针类型,但一般调用_ovfl_get时,这个参数是INTERNAL和LEAF的bytes.上面提到,big data不会在页中记录它们的数据,记录的只是它们数据的地址,这个地址就记录在这个bytes上.这个bytes除了记录地址,还会记录数据的大小,后面就能看到它的用处.
  2. ssz, buf, bufsz起始都是用来表示返回值的.ssz数据的大小, buf表示放data的buffer,也就是数据空间的指针的指针(但是,我没懂,为什么这里要用指针的指针?),bufsz表示buffer的大小.
过程: 
  1. 刚才说过p存的是数据的地址和大小,那么现在就要获得地址和大小.使用memmove函数,然后通过定位指针p和指定获取的数据大小来获得数据.pg获得的是数据起始页面的页号,接着将p移动sizeof(pgno_t)的大小,就能获得数据的大小,记录在sz中.
  2. 如果传入的buffer,即buffsz不够大,也就是比数据大小sz要小,那么就再分配空间.同时buffer的空间大小,*bufsz被更新为sz.
  3. 接下来的for循环和ovfl_put操作的类似,就是将数据从一个个页中读出来.首先计算每个页可以使用的数据大小plen.p指向buf的起始位置,数据不断写入到buf中,p也就不断第移动,每次写完一次数据后,p移动的大小是nb,nb就是循环中每次读的数据大小,pg表示当前读到的页的编号.
  4. 循环开始:首先通过页号获得页面,起始页的页号在上面已经获得.然后比较sz和plen的最小值,起始就是比较要读的数据大小和一个页面大小.为什么要比较,为什么是最小值,原因是put操作类似.
  5. 然后用memmove将数据从页面拷贝到buffer中,p作为的buffer的当前指针,指定将页面内容拷贝到buffer的什么位置.使用完的h页面返回给mpool.
  6. 最后,如果sz-nb=0,也就是数据拷贝完成,就可以退出返回.
  * **__ovfl_delete**
删除大数据,其实就是将放大数据用的页free掉. 参数:p,和get中的意义是一样的. 过程:通过memmove获得初始页的页号,和数据大小.接下来和get一样同样的循环,获得每一个页的页号,调用__bt_free函数释放这个页的空间.