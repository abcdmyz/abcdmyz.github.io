---
layout: post
title: PostgreSQL MVCC （1）
description : ""
category :
tags: []
---

# PostgreSQL MVCC （1）

在写这个之前，罗嗦一些有的没的。MVCC算是事务处理的基础吧，本来是看<Serializable Snapshot Isolation in PostgreSQL>的，论文后面的实现提到如何将SSI加到原有的PostgreSQL上，也就是加到原有的MVCC上。于是就不自觉地去看了MVCC。话说该找个时间写写这篇论文的读后感。跟老板报告MVCC的时候，老板问那你不看SSI了？不看H-Store了？呃......SSI也要在MVCC上实现啊，H-Store好像没有事务的概念了。然后我开始焦虑我的毕业论文...还有实习...还有工作...还有很多很多。......扯淡，扯远了。 现在写的东西基本是“抄袭”那个<MVCC Unmask>的，链接在这<http://momjian.us/main/writings/pgsql/mvcc.pdf> ， slice讲得很详细，而且youtube上一搜就能找到视频。但是，又有一些地方纠结了一下，于是，看着slice，自己配了postgresql，敲敲sql，再来写这篇笔记。不过，因为还是有很多不懂，所以这里只是(1)，希望会赶紧有(2),(3)... 惨了，碎碎念的功力已经到了无可救药的地步了。还是不要罗嗦，赶紧进入正题吧。 

  * **什么是MVCC？**
MVCC的全称 Multi-Version Concurrency Control，多版本并发控制。为什么要多版本？首先想想在2PL（Two Phase Lock）的情况下，读和写是互斥的，正在被读的数据是不能被写的，正在被写的数据是不能被读的，这样的情况下，效率当然会大打折扣。于是就考虑，有一些事务可能是只读事务，只要给他提供数据就可以了，它根本不在乎那些数据是不是最新的。况且按照可串行的说法，我可以说，我就是把你的只读事务安排在了那个写事务之前的，所以你肯定读的不是写以后的数据。那么这种情况下，记录下数据的多个版本就是必要的了。归根到底一句话，为了效率。 
  * **PostgreSQL的MVCC**
PostgreSQL的数据版本是基于事务ID，也就是用事务ID来标记数据版本。而有的数据库，例如Oracle的数据版本是基于时间戳的，就是用时间戳来标记数据版本。PostgreSQL的数据版本是行级（Row-Level）的。任何一行的数据，也就是一条记录被更新了，就会有新的数据产生，当然旧版本的数据是不会马上被删除的，否则怎么会有多版本这说法呢。而Oracle的数据版本是页级（Page-Level）的。任何一个页只要有数据被更新了，就会产生一个新的页。看到这里的时候，我就纳闷，那页级随便改两下就产生新的页，岂不是有很多页？相比之下，行级的岂不是更“精巧”？其实，不然。首先，每个版本都会有“元数据”，同样大小的数据，在行级和页级的情况下，必然是行级的“元数据”多，而且随着数据量的增多，这个“元数据”的差别就会很大很大。其次，很多时候的更新操作都是对一个页内的数据进行的，所以，如果一个页内有100条记录，一个更新操作，对于页级的，只是产生一个新的页，而对于行级的，就是产生100条新的记录。如果事务读多写少，行级的或许更适合。这里也是一个trade-off吧。事务处理处处充满trade-off。我突然又想起了google spanner的原子钟，逆天的东西。（恩，我又扯远了，不要碎碎念，不要碎碎念） 
  * **MVCC Behavior（连题目都是抄袭Slice的）**
![](/wp-content/uploads/2012/10/mvcc_behavior-300x300.png) slice出现的一幅图，（原谅我一直在抄袭吧）。其实很好理解，每个红色的框框代表一个数据版本，也就是一行记录（a tuple/record)。每个框框里有cre和exp，数字分别代表创建这个数据版本和删除这个数据版本的事务ID。对于INSERT操作，exp暂时为空。对于DELETE操作，cre和exp都有值，值可能相等，也可能不等。对于UPDATE操作，其实这里分成了两个操作，一个是DELETE原来的旧数据，一个是INSERT新数据，所以exp和cre的值是相等的。而旧数据虽然被DELETE了，但是不会被马上移走。一是因为，可能有的事务正在读这个数据，二是因为，移走工作当然是批量地干，一条条记录地移走，你以为不费事啊？所以，PostgreSQL是有clean up机制的。 

  * MVCC Visibility（继续抄袭标题）
![](/wp-content/uploads/2012/10/mvcc_visibility.png) 继续slice上面的截图。觉得这页还是有点意思的。一开始我还真没看懂，还纠结了好一会。首先说明visible和invisible的问题。什么数据对于一个事务是visible？已经提交成功的事务产生的数据，（前提是在可重复读和可串行化的隔离级别下）。所以，一个事务对数据的各种增删改查操作，只要这个事务一天不提交，那别的事务就休想看到它干过啥。 说说这个slice的一些前提，其实上面也说得很清楚。首先事务ID随着时间的推移是递增的。当前已经提交的事务最大的ID是100，也就是说超过100的事务ID都还没有提交，或者连开始都还没开始，但不代表低于100的都提交了。open transaction就表示当前还在跑的事务ID，有25,50,75,所以他们对数据干过啥，别人都还不知道，只有他们自己知道。ID低于100的事务，除了这仨外，其他都提交了。 然后从上到下说说那些数据为啥可见或者不可见的。上面那3个数据，create-only，也就是说，目前都还建在，没有被删除。第一个是数据版本ID为30的事务创建的，因为它已经提交了，所以这个数据可见。剩下两个版本一个是ID为50,一个是ID为110的事务创建的，因为这两个事务都还没有提交，所以这两个数据版本就是不可见的。 对于下面的3个数据，expire那都已经有了事务ID了。那是不是就代表这个数据就被删掉了呢？不然。第一个的expire值为80,也就是ID为80的事务把这个数据DELETE了，而且80这个事务已经提交了，所以，这个数据真的是被挪走了，所以就是不可见的了。而下面两个数据，一个的expire值为75,一个为110。不过ID为75和110的事务还没有提交，也就是他们的DELETE操作还没有生效，万一事务回滚了，数据就不会被删除。所以这里的数据是可见的。 所以上面说的什么数据是可见的，除了已经提交成功的事务产生的数据外，还有想要被未提交的事务删除的数据。（不过这说法是不是有点欠缺？） slice中接着来了一段非常长的 && || 组成的代码来判断数据是否可见。慢慢看慢慢纠结就发现真的是这样！ ![](http://abcdmyz.me/wp-content/uploads/2012/10/source_visible.png)

  * **Xmin，Xmax**
上面提到的create和expire在postgreSQL中分别用Xmin和Xmax表示。接着我就开始敲sql了。很囧的是，我用apt-get安装了postgresql后，花了好长时间才纠结出怎样打开postgreSQL。应该再写一篇如何打开postgreSQL的，免得以后自己又忘了。 [sql] DROP TABLE IF EXISTS mvcc_demo; CREATE TABLE mvcc_demo ( val INTEGER ); BEGIN WORK; INSERT INTO mvcc_demo VALUES(1); INSERT INTO mvcc_demo VALUES(2); INSERT INTO mvcc_demo VALUES(3);