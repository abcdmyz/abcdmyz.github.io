---
layout: post
title: 通过时间戳进行事务的并发控制
description : ""
category :
tags: []
---

# 通过时间戳进行事务的并发控制

最近在看《Multi-Version Concurrency via Timestamp Range Conflict Management》这篇论文，结果到现在还没看懂，看得糊里糊涂的。于是开始搜搜这方面的东西，尤其是关于timestamp的。无意中搜到了UIUC数据库课程的资料，其中讲的就是concurrency control via timestamps。然后翻了翻红宝书，发现这个章节原来之前自己看过的，还不止一次，但估计当时没怎么看懂。现在把它再重新看一次，总算有点懂了。于是，想把资料和红宝书的内容结合，写下来。 事务的并发控制一般有两种方式，一种是悲观方式，一种是乐观方式。悲观方式一般用到两阶段锁（2PL）来实现，乐观方式是不用锁机制的。时间戳就是其中一种乐观的并发控制方式。其他的还有多版本并发控制等。这里介绍的时间戳方法并不是多版本的。  **什么是事务时间戳？** 每个事务都会在某个时间点上开始，然后在某个时间点上结束。这两个时间点会形成一个区间。如果一定要给事务一个时间戳，那么这个时间戳就落在这个区间内。至于会挑区间的哪个时间点作为这个事务的时间戳，那就要根据实际需要了。 **什么东西会有时间戳？** 事务会有时间戳。 数据会有时间戳。被事务访问过（读或者写）的数据会有时间戳。由于这里没有考虑多版本，所以数据的时间戳就是最近访问它的事务的时间戳。 **为什么用时间戳进行并发控制？** 并发控制最理想的效果是可串行化。也就是多个并发事务的执行效果等同于按照一定顺序串行执行事务的效果。这里“一定的顺序”到底是什么顺序呢？个人认为这又是一个答案“不确定”的问题。很多时候，我们不是要找这个顺序，而是已经按照一定的方式规定了这个顺序，但不保证这个顺序一定百分之百正确。时间戳就是其中一种方法。在执行过程中，如果发现违反了这个顺序的事务，就会考虑把它终止，以保证最终结果的正确性。（不知道这样的理解是否正确） ![](/wp-content/uploads/2012/06/serial_schedule1-300x147.png) 上图中有T,U,V三个事务，它们是并发的。Actual schedule是它们真正的执行过程。而Serial schedule是它们其中一个串行顺序，这个串行顺序就是按照他们的开始时间排列的，这个开始时间就是事务的时间戳。如果按照这样的顺序执行等同于并发执行的效果，那么这个顺序就是可串行化的。在事务执行的过程中，对于每个事务的每个操作都要检查是否违反了可串行化，如果是，则将该事务终止。 **要记录下什么时间戳？** 将事务的开始时间作为事务的时间戳，用TS(T)表示。 同时，对于每个数据，都要记录下以下内容： RT(X)：表示最近读数据X的事务的时间戳。 WT(X)：表示最近写数据X 的事务的时间戳。 C(X)：表示最近写数据X的事务是否提交。如果等于True，表示已经提交。 **基于时间戳的调度规则 **这里假设数据库的操作有读和写两种。当读或者写一个数据时，都要考虑上一个对此数据进行操作的事务，并通过时间戳的比较得出当前该操作是否可执行。 **T read X：** 当事务T要进行读操作时，要先看最新写过这个数据的时间戳，通过比较决定，该读操作是否可行。因为读读不互斥，所以这里不需要比较读操作。 

  1. TS(T) >= WT(X) ![](/wp-content/uploads/2012/06/read1-300x136.png) 事务T要读数据X，要先看上一个写数据X的事务的时间戳。上图的情况是TS(T)>=WT(X)。这种情况下，有两种可能。如果事务S已经提交了，那么事务T就可以执行。 如果事务S未提交，那么事务T就要等到S提交或者终止，为了防止脏读 (Dirty Read)。
  2. TX(T) < WT(X) ![](/wp-content/uploads/2012/06/read2-300x139.png)[ ](http://abcdmyz.me/wp-content/uploads/2012/06/read2.png)另外一种情况是TS(T)<WT(X)，这种情况下为了可串行化就要终止T，因为按照这里规定的可串行化序列是事务的开始时间，也就是T要在S之前读。如果执行了T的read X，在没有多版本的情况下，T读到的就是S更新中的数据，如果S最后终止了，那么T读到的数据就是无效数据。
**T write X:** 当事务T要进行写操作时，要先看最新读和写过这个数据的时间戳。通过比较决定，该操作是否可行。 

  1. TS(T) < RT(X) ![](/wp-content/uploads/2012/06/write1-300x147.png)[ ](http://abcdmyz.me/wp-content/uploads/2012/06/write1.png)上图中的情况和 T read X 中情况2类似，TS(T)<RT(X)，这里要终止事务T防止不可重复读。因为按照串行化顺序，T是在S之前先执行，所以S应该要读到T更新以后的数据。
  2. TS(T) ≥ RT(X), TS(T) ≥ WT(X) ![](/wp-content/uploads/2012/06/write2-300x155.png)[ ](http://abcdmyz.me/wp-content/uploads/2012/06/write2.png)这里的T可以执行，因为T的时间戳比U和S的都大，也就是T在U和S之后才执行。有考虑过这么一个问题，为什么不需要判断U和S是否已经提交了。因为到T write X这一步，都没有任何不可串行化出现。如果T执行完写以后，U和S再读写X数据，就会造成不可串行化，这个时候再终止U和S即可，与T无关。
  3. TS(T) ≥ RT(X), TS(T) < WT(X) ![](/wp-content/uploads/2012/06/write3-300x157.png)[ ](http://abcdmyz.me/wp-content/uploads/2012/06/write3.png)最后一种情况。如果S已经提交，也就是C(X)=true，那么可忽略T的write X。这种称为Thomas Write Rule。因为按照可串行化顺序，T在S先执行，T的write最终会被S给覆盖掉，所以这里T的write X不需要执行，也不需要终止T。如果S未提交，也就是C(X)=false，那么就要等待S提交或者终止。如果S终止，T就要继续执行write X。
**例子 **左边的T1，T2，T3分别表示3个事务，右边的A，B，C表示3个数据。T1，T2，T3下的200,150,175分别表示事务的时间戳。

T1
T2
T3
A
B
C

200
150
175
RT=0WT=0
RT=0WT=0
RT=0WT=0

R1(B)
 RT=200

R2 (A)
 RT=150

R3 (C)
RT=175

W1 (B)
 WT=200

W1 (A)
 WT=200

W2 (C)

 Abort

W3 (A)