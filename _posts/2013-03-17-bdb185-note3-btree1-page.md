---
layout: post
title: bdb1.85源码学习笔记3_btree1_page
description : ""
category :
tags: []
---

# bdb1.85源码学习笔记3_btree1_page

不知不觉看btree也快2周了,总算看出点眉目.这里先说数据在页面中是以什么格式存储的.我认为,这是最最最关键的地方,数据的存储格式会影响到btree的查询,插入,删除等的操作.其实,在看源码前,我也不知道数据是怎么存储的,也是慢慢看到后面才算弄懂了.然后猛然发现,这些存储方式,不正是课本上讲的么?原来,最后都是一样的东西. 先回忆上次说到的mpool的page,下面的图就能清晰mpool里的页结构. ![](/wp-content/uploads/2013/03/mpool_page_and_head-1024x406.png) 图左边的是页头,记录了与这个页有关的信息.结合以下的代码能看得更其功能系.因为mpool使用两个链表来维护页,一个是lru,另一个是hash,所以对于每个页面都有4个指针.同是每个页面还记录了这个页的相关信息,包括页号,标志位,还有页内容的指针. [c] typedef struct _bkt { CIRCLEQ_ENTRY(_bkt) hq; /* hash queue */ CIRCLEQ_ENTRY(_bkt) q; /* lru queue */ void *page; /* page */ pgno_t pgno; /* page number */ #define MPOOL_DIRTY 0x01 /* page needs to be written */ #define MPOOL_PINNED 0x02 /* page is pinned into memory */ u_int8_t flags; /* flags */ } BKT; [/c]  图右边是把页头和页内容放在了一起,其实他们本来就是连续的一片空间.看看空间分配的代码就很容易理解了.bp指向的空间,先分配了页头大小的空间,也就是sizeof(BKT),然后紧接着是页大小的空间,也就是mp->pagesize.因此页头里的page指针指向的就是紧接着页头的一块空间. [c] BKT* bp = (BKT *)malloc(sizeof(BKT) + mp->pagesize) bp->page = (char *)bp + sizeof(BKT); [/c] 上面说到的页是通用页面,也就是无论btree,hash还是recno都用这个页面.但是,这3者存储数据的格式是不一样的,也就导致了页内容使用方式的不一样.下图把是分析如果这个页用在btree中的情况.把mpool page蓝色的部分(也就是也页内容部分)放大就是btree page的内容.btree中非叶子的页是作为索引页,不存储data,只存key,而叶子页是数据页,既要存储key也要存储data.把btree page中的一个data放大,就可能有两种结果,作为中间页或者作为叶子页.(叶子页...太绕口了) ![](http://abcdmyz.me/wp-content/uploads/2013/03/btree_page-1024x633.png) 接下来结合代码来说明这个图就很容易理解了. 先看看btree page的定义,在/btree/btree.h中. [c] typedef struct _page { pgno_t pgno; /* this page's page number */ pgno_t prevpg; /* left sibling */ pgno_t nextpg; /* right sibling */ #define P_BINTERNAL 0x01 /* btree internal page */ #define P_BLEAF 0x02 /* leaf page */ #define P_OVERFLOW 0x04 /* overflow page */ #define P_RINTERNAL 0x08 /* recno internal page */ #define P_RLEAF 0x10 /* leaf page */ #define P_TYPE 0x1f /* type mask */ #define P_PRESERVE 0x20 /* never delete this chain of pages */ u_int32_t flags; indx_t lower; /* lower bound of free space on page */ indx_t upper; /* upper bound of free space on page */ indx_t linp[1]; /* indx_t-aligned VAR. LENGTH DATA */ } PAGE; [/c] 其实这个结构体定义的就是btree page的页头,记录了这个页的信息,包括页号,前一个页的页号,后一个页的页号,标志位,还有剩余空间的起始和末尾位置.从prevpg和nextpg来看,这棵btree应该是等高的,否则记录左右兄弟就显得没什么意义了.lower和upper,在图中没有标示出来,如果要标示,low应该就在linp[3]末尾位置,upper应该在data[2]的起始位置.最后关于linp[],一开始的时候,我真没懂,为什么要定义11个大小的数组?只有1个大小的数组能放什么?后来查了资料才知道,起始数组是可以扩容的.想想刚才在分配空间的时候,这个page可是分配了一定的空间的,出去btree page head要用的空间,剩下的都是linp[]的空间了.从图上也能看出来. 那么btree page里的数据是怎么放的?怎么用linp[]来放?linp的类型只是int而已,所以它存的不是数据,而是数据的指针.而且这个指针所存的地址,是相对地址,也就是在页中的偏移.数据被放在页尾,而且是从末尾开始放,不断往前放.而linp指向的就是每个数据块的起始地址. 其实/btree/btree.h里我是看不出这些的,是看到后面的search,put等等,才算看明白了数据是这么放的. 接下来再看看中间页和叶子页的定义,再对比这幅图,就很好理解了.无论是中间页还是叶子页,它们都会有页头,而接下来的数据都放在bytes[]里. [c] typedef struct _binternal { u_int32_t ksize; /* key size */ pgno_t pgno; /* page number stored on */ #define P_BIGDATA 0x01 /* overflow data */ #define P_BIGKEY 0x02 /* overflow key */ u_char flags; char bytes[1]; /* data */ } BINTERNAL typedef struct _bleaf { u_int32_t ksize; /* size of key */ u_int32_t dsize; /* size of data */ u_char flags; /* P_BIGDATA, P_BIGKEY */ char bytes[1]; /* data */ } BLEAF; [/c] 在/btree/btree.h里还有很多很有用的宏定义. [c] #define BTDATAOFF \ (sizeof(pgno_t) + sizeof(pgno_t) + sizeof(pgno_t) + \ sizeof(u_int32_t) + sizeof(indx_t) + sizeof(indx_t)) #define NEXTINDEX(p) (((p)->lower - BTDATAOFF) / sizeof(indx_t)) [/c] NEXTINDEX是获得下一个index,其中一个使用的场景是,如果插入一个新的数据,这个数据的指针下标就应该是NEXTINDEX.结合上面的图中来说,这时候获得的index应该是4.计算的方式是把用page的lower位移减去页头的大小,因为页头的数据大小是固定的,那么剩下的就是已经使用的linp[]大小,除以每个linp的大小,就能获得next index. [c] #define GETBINTERNAL(pg, indx) \ ((BINTERNAL *)((char *)(pg) + (pg)->linp[indx])) #define GETBLEAF(pg, indx) \ ((BLEAF *)((char *)(pg) + (pg)->linp[indx])) [/c] 如果上面理解了,这两个宏定义也很好理解了.它们分别是获得中间页和叶子页指定index的数据.上面提到linp[]记录的是数据在页内的相对位移,所以只要将指针移动到linp[index]所指的位置即可.然后用强制类型转换,就能或者结构体里指定的数据了. [c] typedef struct _epgno { pgno_t pgno; /* the page number */ indx_t index; /* the index on the page */ } EPGNO; typedef struct _epg { PAGE *page; /* the (pinned) page */ indx_t index; /* the index on the page */ } EPG; [/c] 这两个结构体的定义,我的理解就是对数据的封装.如果现在有一个请求是访问指定页面指定index的数据,那么这两个结构体就是讲这两个指定的内容进行封装,将要传递的参数从2个降为1个.而且传达参数的含义也更加清晰. /btree/btree.h里还有很多其他的定义,这里不一一列举.后面用到了再解释,会更好理解.